// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lyrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum LyricsRestriction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unrestricted // = 0
  case showLyrics // = 1
  case showLyricsMonthlyLimit // = 2
  case monthlyLimitReached // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unrestricted
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unrestricted
    case 1: self = .showLyrics
    case 2: self = .showLyricsMonthlyLimit
    case 3: self = .monthlyLimitReached
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unrestricted: return 0
    case .showLyrics: return 1
    case .showLyricsMonthlyLimit: return 2
    case .monthlyLimitReached: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension LyricsRestriction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LyricsRestriction] = [
    .unrestricted,
    .showLyrics,
    .showLyricsMonthlyLimit,
    .monthlyLimitReached,
  ]
}

#endif  // swift(>=4.2)

struct LyricsLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offsetMs: Int32 = 0

  var content: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LyricsColors {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var backgroundColor: UInt32 = 0

  var lineColor: UInt32 = 0

  var activeLineColor: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LyricsTranslation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var languageCode: String = String()

  var lines: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct LyricsData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeSynchronized: Bool = false

  var lines: [LyricsLine] = []

  var providedBy: String = String()

  var restriction: LyricsRestriction = .unrestricted

  var translation: LyricsTranslation {
    get {return _translation ?? LyricsTranslation()}
    set {_translation = newValue}
  }
  /// Returns true if `translation` has been explicitly set.
  var hasTranslation: Bool {return self._translation != nil}
  /// Clears the value of `translation`. Subsequent reads from it will return its default value.
  mutating func clearTranslation() {self._translation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _translation: LyricsTranslation? = nil
}

struct Lyrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: LyricsData {
    get {return _data ?? LyricsData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var colors: LyricsColors {
    get {return _colors ?? LyricsColors()}
    set {_colors = newValue}
  }
  /// Returns true if `colors` has been explicitly set.
  var hasColors: Bool {return self._colors != nil}
  /// Clears the value of `colors`. Subsequent reads from it will return its default value.
  mutating func clearColors() {self._colors = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: LyricsData? = nil
  fileprivate var _colors: LyricsColors? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension LyricsRestriction: @unchecked Sendable {}
extension LyricsLine: @unchecked Sendable {}
extension LyricsColors: @unchecked Sendable {}
extension LyricsTranslation: @unchecked Sendable {}
extension LyricsData: @unchecked Sendable {}
extension Lyrics: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension LyricsRestriction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNRESTRICTED"),
    1: .same(proto: "SHOW_LYRICS"),
    2: .same(proto: "SHOW_LYRICS_MONTHLY_LIMIT"),
    3: .same(proto: "MONTHLY_LIMIT_REACHED"),
  ]
}

extension LyricsLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LyricsLine"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offsetMs"),
    2: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.offsetMs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offsetMs != 0 {
      try visitor.visitSingularInt32Field(value: self.offsetMs, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LyricsLine, rhs: LyricsLine) -> Bool {
    if lhs.offsetMs != rhs.offsetMs {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LyricsColors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LyricsColors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backgroundColor"),
    2: .same(proto: "lineColor"),
    3: .same(proto: "activeLineColor"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.backgroundColor) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.lineColor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.activeLineColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.backgroundColor != 0 {
      try visitor.visitSingularUInt32Field(value: self.backgroundColor, fieldNumber: 1)
    }
    if self.lineColor != 0 {
      try visitor.visitSingularUInt32Field(value: self.lineColor, fieldNumber: 2)
    }
    if self.activeLineColor != 0 {
      try visitor.visitSingularUInt32Field(value: self.activeLineColor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LyricsColors, rhs: LyricsColors) -> Bool {
    if lhs.backgroundColor != rhs.backgroundColor {return false}
    if lhs.lineColor != rhs.lineColor {return false}
    if lhs.activeLineColor != rhs.activeLineColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LyricsTranslation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LyricsTranslation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "languageCode"),
    2: .same(proto: "lines"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.lines) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedStringField(value: self.lines, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LyricsTranslation, rhs: LyricsTranslation) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LyricsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LyricsData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeSynchronized"),
    2: .same(proto: "lines"),
    5: .same(proto: "providedBy"),
    14: .same(proto: "restriction"),
    9: .same(proto: "translation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.timeSynchronized) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.lines) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.providedBy) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._translation) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self.restriction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeSynchronized != false {
      try visitor.visitSingularBoolField(value: self.timeSynchronized, fieldNumber: 1)
    }
    if !self.lines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lines, fieldNumber: 2)
    }
    if !self.providedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.providedBy, fieldNumber: 5)
    }
    try { if let v = self._translation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.restriction != .unrestricted {
      try visitor.visitSingularEnumField(value: self.restriction, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LyricsData, rhs: LyricsData) -> Bool {
    if lhs.timeSynchronized != rhs.timeSynchronized {return false}
    if lhs.lines != rhs.lines {return false}
    if lhs.providedBy != rhs.providedBy {return false}
    if lhs.restriction != rhs.restriction {return false}
    if lhs._translation != rhs._translation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lyrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Lyrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "colors"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._colors) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._colors {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lyrics, rhs: Lyrics) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._colors != rhs._colors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
